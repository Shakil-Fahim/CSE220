# -*- coding: utf-8 -*-
"""assignment06_binary_tree

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c2jiP_4cBgmR-6q3NO1pAhXxAq4Kv5qA
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def tree_construction(arr, i = 1):
  if i>=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p


root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'k'])
inorder(root2)

"""Task 1"""

def convert_mirror(root):
    if   root==None:
       return root
    convert_mirror(root.left)
    convert_mirror(root.right)
    swap=root.left
    root.left=root.right
    root.right=swap
    return root

#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()

root2 = convert_mirror(root)
print('Mirrored Tree Inorder Traversal: ', end = ' ')
inorder(root2) #Mirrored Tree Inorder Traversal:  30 10 60 20 40

"""Task 2"""

def smallest_level(root, level = {}, i = 0):
    if   root == None:
        return level
    if  i not in level:
          level[i] = root.elem
    else:
      if  root.elem < level[i]:
        level[i] = root.elem

    smallest_level(root.left,level, i+1)
    smallest_level(root.right,level, i+1)

    return  level

#DRIVER CODE
root = tree_construction([None, 4,9,2,3,-5,None,7])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  3 9 5 4 2 7
print()
print('Level Wise Smallest Value: ', end = ' ')
print(smallest_level(root)) #Level Wise Smallest Value:  {0: 4, 1: 2, 2: -5}

"""Task 3"""

def sumTree(root):

      def sum(node, level):
        if node is None:
            return 0
        if level == 0:
            current_sum = node.elem
        else:
            current_sum = node.elem % level
        left_sum = sum(node.left, level + 1)
        right_sum = sum(node.right, level + 1)

        return current_sum + left_sum + right_sum
      return sum(root, 0)

#Driver Code
#Input 1
root1 = BTNode(9)
node2 = BTNode(4)
node3 = BTNode(5)
node4 = BTNode(18)
node5 = BTNode(14)
node6 = BTNode(3)
node7 = BTNode(54)
node8 = BTNode(12)
node9 = BTNode(8)
node10 = BTNode(91)
node11 = BTNode(56)

root1.left = node2
root1.right = node3

node2.left = node4

node3.left = node5
node3.right = node6

node4.left = node7
node4.right = node8

node5.left = node9

node8.left = node10
node8.right = node11

print(sumTree(root1)) #This should print 15

"""Task 4

"""

def swap_child(root, level, M):
    if  root  is  None:
        return root
    if  level >=  M:
        temp =  root.left
        root.left =  root.right
        root.right =  temp
    root.left =  swap_child(root.left, level + 1, M)
    root.right =  swap_child(root.right, level + 1, M)

    return root



root = BTNode('A')
node_b = BTNode('B')
node_c = BTNode('C')
node_d = BTNode('D')
node_e = BTNode('E')
node_f = BTNode('F')
node_g = BTNode('G')
node_h = BTNode('H')
node_i = BTNode('I')
node_j = BTNode('J')


root.left = node_b
root.right = node_c
node_b.left = node_d
node_b.right = node_e
node_c.left = node_f
node_d.left = node_g
node_d.right = node_h
node_e.right = node_i
node_f.left = node_j

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root)   #Given Tree Inorder Traversal: G D H B I E A C J F
print()

root2 = swap_child(root, 0, 2)
print('Swapped Tree Inorder Traversal: ', end = ' ')
inorder(root2)  #Swapped Tree Inorder Traversal: J F C A I E B G D H

"""Task 5"""

def sum_subtree(root):

    if root is None:
        return 0

    return root.elem + sum_subtree(root.left) + sum_subtree(root.right)

def subtract_summation(root):

    if root is None:
        return 0

    left_sum = sum_subtree(root.left)

    right_sum = sum_subtree(root.right)

    return left_sum - right_sum
#Driver Code
root=BTNode(71)
root = BTNode(71)
root.left = BTNode(27)
root.right = BTNode(62)
root.left.left = BTNode(75)
root.left.right = BTNode(80)
root.left.left.left = BTNode(87)
root.left.left.right = BTNode(56)
root.right.left = BTNode(41)
root.right.right = BTNode(3)
root.right.left.left = BTNode(19)
root.right.left.right = BTNode(89)


print(subtract_summation(root)) #This should print 111

"""Task 6"""

def level_sum(root):
    def compute_sums(node, level):
        if  node is  None:
            return 0, 0
        left_odd,  left_even  =  compute_sums(node.left, level + 1)
        right_odd,  right_even =  compute_sums(node.right, level + 1)
        odd_sum  =  left_odd  +  right_odd
        even_sum  =  left_even + right_even
        if  level  % 2  ==  1:
            odd_sum  +=  node.elem
        else:
            even_sum  +=  node.elem

        return odd_sum, even_sum

    if  root  is  None:
        return 0
    odd_sum, even_sum  =  compute_sums(root, 1)
    return even_sum - odd_sum
root = BTNode(1)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(4)
n5 = BTNode(5)
n6 = BTNode(6)
n7 = BTNode(7)
n8 = BTNode(8)
root.left = n2
root.right = n3

n2.left = n4
n3.left = n5
n3.right = n6

n5.left = n7
n5.right = n8


print(level_sum(root)) #This should print 4